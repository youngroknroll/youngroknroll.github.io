---
title: "제1부: 도메인 모델링을 지원하는 아키텍처 구축"
description: "Cosmic Python Part 1 - 도메인 모델을 중심에 두고, 인프라로부터 비즈니스 로직을 분리하는 아키텍처 패턴들을 알아보자"
date: 2026-01-12 10:00:00 +0900
categories: [CS, Common]
tags: [Computer Science, Architecture, DDD, TDD, Cosmic Python]
image: https://www.cosmicpython.com/images/seagull_nebula_jpl.jpeg
---

# 제1부: 도메인 모델링을 지원하는 아키텍처 구축

> "대부분의 개발자는 도메인 모델을 본 적이 없다. 그들이 본 것은 데이터 모델뿐이다."
> — Cyrille Martraire, DDD EU 2017

---

## 왜 이 책을 읽어야 할까?

우리가 흔히 하는 개발 방식을 떠올려보자.
1. 데이터베이스 스키마를 먼저 설계하고
2. ORM 모델을 만들고
3. 그 위에 비즈니스 로직을 얹는다

이 방식이 뭐가 문제일까?

**비즈니스 로직이 코드 여기저기에 흩어진다.** 컨트롤러에도 있고, 모델에도 있고, 유틸리티 함수에도 있다.
시간이 지나면 "이 로직이 어디에 있더라?" 하면서 코드를 뒤지게 된다.

Cosmic Python의 저자들은 이 접근을 **뒤집자**고 제안한다.

> **"저장소가 행동을 결정하는 게 아니라, 행동이 저장소를 결정해야 한다."**

비즈니스 로직을 먼저 설계하고, 데이터베이스는 나중에 생각하자는 것이다.

---

## Part 1에서 다루는 핵심 패턴들

Part 1은 총 7개의 챕터로 구성되어 있다. 각 챕터가 하나의 패턴을 점진적으로 쌓아 올린다.

| 챕터 | 패턴 | 핵심 질문 |
|------|------|----------|
| Ch1 | 도메인 모델링 | "비즈니스 로직을 어떻게 코드로 표현할까?" |
| Ch2 | Repository 패턴 | "도메인 모델을 DB에서 어떻게 분리할까?" |
| Ch3 | 결합도와 추상화 | "좋은 추상화란 무엇일까?" |
| Ch4 | Service Layer | "유스케이스를 어디에 넣을까?" |
| Ch5 | TDD | "테스트 피라미드를 어떻게 최적화할까?" |
| Ch6 | Unit of Work | "트랜잭션을 어떻게 깔끔하게 관리할까?" |
| Ch7 | Aggregate | "일관성 경계를 어떻게 설정할까?" |

---

# Chapter 1: 도메인 모델링(Domain Modeling)

## 도메인 모델이란?

도메인 모델은 **"비즈니스 문제를 코드로 표현한 것"**이다.
이 책에서는 가구 소매업체의 **재고 할당 시스템**을 예시로 사용한다.

핵심 비즈니스 규칙은 이렇다.
- 고객이 주문하면 → 가용 재고에서 **할당(allocate)**한다
- 창고 재고를 먼저 할당하고, 입고 예정 배치는 나중에 할당한다
- 같은 주문 라인을 두 번 할당할 수 없다
- 재고가 부족하면 할당 실패

---

## 값 객체(Value Object)와 엔터티(Entity)

DDD에서 가장 기본적인 두 가지 개념이다.

### 값 객체: "무엇이냐"가 중요

```python
@dataclass(frozen=True)
class OrderLine:
    orderid: str
    sku: str
    qty: int
```

`frozen=True`로 **불변(immutable)**하게 만든다.
같은 `orderid`, `sku`, `qty`를 가진 두 OrderLine은 **동일한 것**이다. 정체성(identity)이 없고, 값 자체가 의미다.

### 엔터티: "누구냐"가 중요

```python
class Batch:
    def __init__(self, ref: str, sku: str, qty: int, eta: Optional[date]):
        self.reference = ref
        self.sku = sku
        self.eta = eta
        self._purchased_quantity = qty
        self._allocations = set()

    def allocate(self, line: OrderLine):
        if self.can_allocate(line):
            self._allocations.add(line)

    def can_allocate(self, line: OrderLine) -> bool:
        return self.sku == line.sku and self.available_quantity >= line.qty

    @property
    def available_quantity(self) -> int:
        return self._purchased_quantity - self.allocated_quantity

    @property
    def allocated_quantity(self) -> int:
        return sum(line.qty for line in self._allocations)
```

Batch는 `reference`라는 **고유 식별자**를 가진다.
수량이 바뀌거나 할당이 추가되어도, 같은 `reference`면 같은 Batch다.

| 구분 | 값 객체(Value Object) | 엔터티(Entity) |
|------|---------------------|---------------|
| **동일성 기준** | 값이 같으면 같다 | 식별자가 같으면 같다 |
| **불변성** | 불변 | 변경 가능 |
| **예시** | OrderLine, 주소, 가격 | Batch, 주문, 고객 |

---

## 도메인 서비스 함수

모든 로직이 객체에 담기는 건 아니다. **"할당한다"**라는 행위는 특정 객체에 속하지 않는다.
이런 경우 **도메인 서비스 함수**로 표현한다.

```python
def allocate(line: OrderLine, batches: List[Batch]) -> str:
    try:
        batch = next(
            b for b in sorted(batches) if b.can_allocate(line)
        )
    except StopIteration:
        raise OutOfStock(f"Out of stock for sku {line.sku}")
    batch.allocate(line)
    return batch.reference
```

비즈니스 규칙이 그대로 코드에 녹아 있다.
- `sorted(batches)`: 창고 재고(ETA 없음)를 먼저, 그 다음은 입고일 빠른 순서로
- `can_allocate`: SKU가 맞고 수량이 충분한지 확인
- `OutOfStock`: 재고 부족이라는 도메인 예외

---

# Chapter 2: Repository 패턴

## 문제: ORM이 도메인을 오염시킨다

보통 Django나 SQLAlchemy를 쓰면, 도메인 모델이 ORM에 종속된다.
`models.Model`을 상속받거나, ORM 필드를 직접 정의하게 되면 **도메인 모델이 인프라를 알게 된다.**

그런데 도메인 모델은 **비즈니스 로직만 알아야 한다.** 데이터베이스가 MySQL인지 PostgreSQL인지, ORM이 뭔지 몰라도 되어야 한다.

## 해결: 의존성 역전(Dependency Inversion)

> **"인프라가 도메인에 의존해야지, 도메인이 인프라에 의존하면 안 된다."**

Repository 패턴은 **영속성 저장소에 대한 추상화**다.
마치 인메모리 컬렉션처럼 `add()`와 `get()`만 제공한다.

```python
class AbstractRepository(abc.ABC):
    @abc.abstractmethod
    def add(self, entity):
        raise NotImplementedError

    @abc.abstractmethod
    def get(self, reference) -> model.Batch:
        raise NotImplementedError
```

### 실제 구현 (SQLAlchemy)

```python
class SqlAlchemyRepository(AbstractRepository):
    def __init__(self, session):
        self.session = session

    def add(self, batch):
        self.session.add(batch)

    def get(self, reference):
        return self.session.query(model.Batch)\
            .filter_by(reference=reference).one()
```

### 테스트용 Fake 구현

```python
class FakeRepository(AbstractRepository):
    def __init__(self, batches):
        self._batches = set(batches)

    def add(self, batch):
        self._batches.add(batch)

    def get(self, reference):
        return next(b for b in self._batches
                    if b.reference == reference)
```

데이터베이스 없이도 테스트를 돌릴 수 있다. **테스트가 빨라지고 안정적**이 된다.

> `AbstractRepository`는 **포트(Port)**, `SqlAlchemyRepository`와 `FakeRepository`는 **어댑터(Adapter)**다.
> 이것이 바로 포트-어댑터(헥사고날) 아키텍처의 핵심이다.

---

# Chapter 4: Service Layer (서비스 레이어)

## 문제: Flask 엔드포인트가 너무 뚱뚱하다

웹 컨트롤러에 비즈니스 로직을 넣으면 어떻게 될까?

```python
@app.route("/allocate", methods=["POST"])
def allocate_endpoint():
    session = get_session()
    batches = repository.SqlAlchemyRepository(session).list()
    line = model.OrderLine(
        request.json["orderid"],
        request.json["sku"],
        request.json["qty"],
    )
    # 검증 로직, 에러 처리, 도메인 로직, 커밋... 전부 여기에?
```

컨트롤러가 **검증, 비즈니스 로직, 데이터 접근, 에러 처리**를 전부 담당하게 된다.
테스트하려면 HTTP 요청을 보내야 하고, DB가 떠 있어야 한다.

## 해결: 서비스 레이어로 오케스트레이션 분리

서비스 레이어는 **유스케이스의 오케스트레이션(조율)**을 담당한다.
직접 비즈니스 로직을 수행하는 게 아니라, **도메인 모델을 호출**하는 역할이다.

```python
def allocate(orderid: str, sku: str, qty: int,
             repo: AbstractRepository, session) -> str:
    batches = repo.list()
    if not is_valid_sku(sku, batches):
        raise InvalidSku(f"Invalid sku {sku}")
    line = OrderLine(orderid, sku, qty)
    batchref = model.allocate(line, batches)
    session.commit()
    return batchref
```

이제 Flask 엔드포인트는 **요청 파싱과 응답 반환**만 한다.

```python
@app.route("/allocate", methods=["POST"])
def allocate_endpoint():
    try:
        batchref = services.allocate(
            request.json["orderid"],
            request.json["sku"],
            request.json["qty"],
            repo, session,
        )
    except services.InvalidSku as e:
        return {"message": str(e)}, 400
    return {"batchref": batchref}, 201
```

### 두 종류의 "서비스"를 구분하자

| 구분 | 애플리케이션 서비스 (Service Layer) | 도메인 서비스 |
|------|--------------------------------|-------------|
| **역할** | 외부 요청을 받아서 조율 | 비즈니스 로직 수행 |
| **예시** | `services.allocate()` | `model.allocate()` |
| **알고 있는 것** | Repository, UoW, 도메인 모델 | 순수 도메인 개념만 |

서비스 레이어는 **"할 일을 조율"**하고, 도메인 서비스는 **"실제로 일을 수행"**한다.
비즈니스 로직이 서비스 레이어로 새어나가지 않도록 주의해야 한다. (빈약한 도메인 모델 안티패턴)

---

# Chapter 6: Unit of Work 패턴

## 문제: 트랜잭션 관리가 지저분하다

서비스 레이어에서 `session`을 직접 다루면, 커밋/롤백 로직이 서비스마다 반복된다.
그리고 서비스 레이어가 `session`이라는 **인프라 세부사항**을 알고 있어야 한다.

## 해결: Unit of Work로 원자적 연산 추상화

Unit of Work는 **"이 작업들은 전부 성공하거나, 전부 실패해야 한다"**를 표현하는 패턴이다.
Python의 컨텍스트 매니저(`with` 문)와 찰떡궁합이다.

```python
class AbstractUnitOfWork(abc.ABC):
    products: AbstractRepository

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.rollback()

    @abc.abstractmethod
    def commit(self):
        raise NotImplementedError

    @abc.abstractmethod
    def rollback(self):
        raise NotImplementedError
```

### SQLAlchemy 구현

```python
class SqlAlchemyUnitOfWork(AbstractUnitOfWork):
    def __init__(self, session_factory=DEFAULT_SESSION_FACTORY):
        self.session_factory = session_factory

    def __enter__(self):
        self.session = self.session_factory()
        self.products = SqlAlchemyRepository(self.session)
        return self

    def __exit__(self, *args):
        super().__exit__(*args)
        self.session.close()

    def commit(self):
        self.session.commit()

    def rollback(self):
        self.session.rollback()
```

### 서비스 레이어가 깔끔해진다

```python
def allocate(orderid: str, sku: str, qty: int,
             uow: AbstractUnitOfWork) -> str:
    line = OrderLine(orderid, sku, qty)
    with uow:
        product = uow.products.get(sku=sku)
        if product is None:
            raise InvalidSku(f"Invalid sku {sku}")
        batchref = product.allocate(line)
        uow.commit()
        return batchref
```

`session`이 사라지고, `uow` 하나로 통합되었다.
- `with uow:` — 트랜잭션 시작
- `uow.products` — Repository 접근
- `uow.commit()` — 명시적 커밋
- 예외 발생 시 — 자동 롤백 (`__exit__`에서)

> **명시적 커밋, 암묵적 롤백.** 성공적인 경로에서만 `commit()`이 호출되고, 그 외에는 모두 롤백된다.

---

# Chapter 7: Aggregate와 일관성 경계

## 문제: 동시성 환경에서 일관성을 어떻게 보장할까?

두 명의 사용자가 동시에 같은 SKU의 재고를 할당하려고 한다면?
둘 다 "재고 10개 남음"을 읽고, 둘 다 할당에 성공하면 **재고가 마이너스**가 될 수 있다.

## 해결: Aggregate로 일관성 경계 설정

**Aggregate는 데이터 변경의 단위로 취급하는 관련 객체들의 클러스터**다. (Eric Evans)

```python
class Product:
    def __init__(self, sku: str, batches: List[Batch],
                 version_number: int = 0):
        self.sku = sku
        self.batches = batches
        self.version_number = version_number

    def allocate(self, line: OrderLine) -> str:
        try:
            batch = next(
                b for b in sorted(self.batches)
                if b.can_allocate(line)
            )
            batch.allocate(line)
            self.version_number += 1
            return batch.reference
        except StopIteration:
            raise OutOfStock(f"Out of stock for sku {line.sku}")
```

핵심 원칙들을 정리하면 이렇다.

### 1. Aggregate가 유일한 진입점

Batch를 직접 수정하지 않는다. **반드시 Product를 통해서만 접근**한다.
이렇게 하면 Product가 내부 일관성을 보장할 수 있다.

### 2. 하나의 Aggregate = 하나의 Repository

```
BatchRepository (X) → ProductRepository (O)
```

Repository는 Aggregate 단위로 만든다. Batch를 직접 꺼내오는 Repository는 없다.

### 3. 낙관적 동시성 제어 (Optimistic Concurrency)

`version_number`를 사용한다.
- 할당할 때마다 `version_number`를 증가시킨다
- 커밋 시점에 DB의 `version_number`와 비교한다
- 다른 트랜잭션이 먼저 수정했으면 **충돌 감지 → 재시도**

```python
# 비관적 잠금 방식도 가능
def get(self, sku):
    return (
        self.session.query(model.Product)
        .filter_by(sku=sku)
        .with_for_update()  # SELECT FOR UPDATE
        .first()
    )
```

| 구분 | 낙관적 잠금 | 비관적 잠금 |
|------|-----------|-----------|
| **전략** | 충돌이 드물다고 가정 | 충돌이 빈번하다고 가정 |
| **동작** | 커밋 시점에 충돌 감지 | 읽기 시점에 잠금 획득 |
| **성능** | 경합이 적으면 좋다 | 경합이 많으면 좋다 |
| **구현** | version_number | SELECT FOR UPDATE |

---

## Part 1의 큰 그림

Part 1의 모든 패턴이 어떻게 조합되는지 정리해보자.

```
Flask / CLI (진입점)
    │
    ▼
Service Layer (유스케이스 오케스트레이션)
    │
    ├─ Unit of Work (트랜잭션 관리)
    │   │
    │   └─ Repository (영속성 추상화)
    │       │
    │       └─ Aggregate (일관성 경계)
    │           │
    │           └─ Domain Model (비즈니스 로직)
    │
    ▼
Database (인프라)
```

**의존성 방향은 항상 안쪽으로 향한다.**
- Flask는 Service Layer를 안다
- Service Layer는 UoW와 도메인 모델을 안다
- 도메인 모델은 **아무것도 모른다** (순수 파이썬)

이것이 **양파(Onion) 아키텍처**의 핵심이다. 도메인 모델이 중심에 있고, 인프라가 바깥을 감싼다.

---

## Part 1 트레이드오프 총정리

| 패턴 | 얻는 것 | 잃는 것 |
|------|--------|--------|
| **Domain Model** | 비즈니스 로직이 명확하게 표현됨 | 단순 CRUD에는 과하다 |
| **Repository** | DB 독립적인 테스트, 저장소 교체 가능 | ORM 매핑 설정이 추가됨 |
| **Service Layer** | 유스케이스가 명확히 분리됨 | 추상화 레이어가 하나 더 생긴다 |
| **Unit of Work** | 트랜잭션이 깔끔하게 관리됨 | SQLAlchemy가 이미 제공하는 기능이기도 하다 |
| **Aggregate** | 동시성 환경에서 일관성 보장 | 개발자의 사고방식 전환이 필요하다 |

> 이 패턴들은 **도메인이 복잡할수록** 빛을 발한다.
> 단순한 CRUD 앱이라면 오히려 과한 투자일 수 있다. 복잡도에 따라 판단하자.

---

## 다음은 Part 2

Part 1에서 단일 도메인 모델을 위한 탄탄한 아키텍처를 구축했다.
하지만 현실에서는 **여러 모델이 서로 협력**해야 하고, **외부 시스템과 통신**해야 한다.

Part 2에서는 이벤트 기반 아키텍처를 통해 이 문제를 다룬다.
- 도메인 이벤트로 Aggregate 간 통신
- 메시지 버스로 유스케이스 통합
- CQRS로 읽기/쓰기 분리
- 의존성 주입으로 전체 구조 정리

> [제2부: 이벤트 기반 아키텍처(Event-Driven Architecture)](https://crescentfull.github.io/posts/part2/)에서 이어진다.

---

참고 자료
- [Cosmic Python - Part 1: Building an Architecture to Support Domain Modeling](https://www.cosmicpython.com/book/part1.html)
- [Cosmic Python - Chapter 1: Domain Modeling](https://www.cosmicpython.com/book/chapter_01_domain_model.html)
- [Cosmic Python - Chapter 2: Repository Pattern](https://www.cosmicpython.com/book/chapter_02_repository.html)
- [Cosmic Python - Chapter 4: Service Layer](https://www.cosmicpython.com/book/chapter_04_service_layer.html)
- [Cosmic Python - Chapter 6: Unit of Work Pattern](https://www.cosmicpython.com/book/chapter_06_uow.html)
- [Cosmic Python - Chapter 7: Aggregates and Consistency Boundaries](https://www.cosmicpython.com/book/chapter_07_aggregate.html)
- [Cosmic Python 전체 목차](https://www.cosmicpython.com/book/preface.html)
